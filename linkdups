#!/usr/bin/perl
#
# linkdups - Find duplicate files in a directory tree and link() them.
#
# Copyright (C) 2000-2022 Steven Pritchard <steven.pritchard@gmail.com>
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

use strict;
use warnings;

use Getopt::Std;
use Digest::MD5;
use FileHandle;
use DirHandle;
use File::Basename;
use DBI;

# Work around *stupid* File::Spec::Unix bug.
if (!$^V or $^V lt v5.10.0) {
    no warnings;

    package File::Spec::Unix;

    sub _cwd {
        require Cwd;
        Cwd::getcwd();
    }

}
# END STUPID WORKAROUND.

our $dbver = 1;
our $dbfile = ":memory:";

our @statbuf = ();

our $total = 0;
our $numtotal = 0;
our $num = 0;
our $start = 0;
our $pass1 = 0;

our %files = ();

our $recursive;
our $verbose;
our $debug;
our $dryrun;
our $usetimes;

our $dbh;

sub usage {
    print STDERR <<END;

Usage: @{[basename($0)]} [options] [files]

    -h          Print this message.
    -r          Work recursively.
    -v          Be more verbose.
    -D          Turn on debugging.
    -n          Don't link anything, just list what would be one (dry run).
    -t          Only link files that have identical timestamps.
    -c file     Cache results in file.

END

    exit $_[0];

}

sub info {
    print @_ if ($verbose or $debug);
}

sub debug {
    print STDERR @_ if ($debug);
}

sub recurse_into {
    my $dir = shift;

    if (opendir(DIR, $dir)) {
        for my $x (grep(!/^\.\.?$/, readdir(DIR))) {
            @statbuf = lstat("$dir/$x");
            if (-d(_)) {
                recurse_into("$dir/$x");
            } elsif (-f(_)) {
                stuff("$dir/$x");
            } else {
                debug(basename($0),
                    ": '$dir/$x' is not a plain file, skipping...\n");
            }
        }
    } else {
        warn "Can't open $dir: $!\n";
    }
}

sub stuff {
    my $file = shift;

    $numtotal++;

    my $sth = sql_execute($dbh,
        'select id,nlink,uid,gid,size,blocks,mtime,md5 from inode'
        . ' where dev=? and inum=?',
        $statbuf[0], $statbuf[1]);

    if (my $inode = $sth->fetchrow_hashref) {
        my $needs_update = 0;
        my $needs_checksum = 0;

        if ($inode->{'nlink'}  != $statbuf[3]
         or $inode->{'uid'}    != $statbuf[4]
         or $inode->{'gid'}    != $statbuf[5]
         or $inode->{'blocks'} != $statbuf[12]) {
            $needs_update = 1;
        } elsif ($inode->{'size'}  != $statbuf[7]
              or $inode->{'mtime'} != $statbuf[9]) {
            $needs_update = 1;
            $needs_checksum = 1;
        }

        if ($needs_update) {
            sql_execute($dbh,
                'update inode set nlink=?,uid=?,gid=?,size=?,blocks=?,mtime=?'
                . ($needs_checksum ? ',md5=NULL' : '')
                . ' where id=?',
                @statbuf[3..5],
                $statbuf[7],
                $statbuf[12],
                $statbuf[9],
                $inode->{'id'});
        }
    } else {
        sql_execute($dbh,
            'insert into inode'
            . ' (dev,inum,nlink,uid,gid,size,blocks,mtime)'
            . ' values (?,?,?,?,?,?,?,?)',
            @statbuf[0..1],
            @statbuf[3..5],
            $statbuf[7],
            $statbuf[12],
            $statbuf[9]);
    }

    sql_execute($dbh, 'insert into file (dev,inum,name) values (?,?,?)',
        @statbuf[0..1], $file);

    return 1;
}

sub checksum {
# FIXME
    my ($context,$i) = @_;

#    return if (exists($i->{'md5sum'}));
#
#    # Pick the first file in the list and md5sum that.
#    my $file = $i->{'files'}->[0];
    my $file = $i->{'name'};

    my $fh = new FileHandle $file, "r";
    if (!defined($fh)) {
        warn "Failed to open $file: $!\n";
        return;
    }

    $num++;

    $context->reset();
    $context->addfile($fh);
    $fh->close();
    my $hash = $context->hexdigest();
    debug("$hash  $file\n");
#    $i->{'md5sum'} = $hash;

    sql_execute($dbh, "update inode set md5=? where dev=? and inum=?",
        $hash, $i->{'dev'}, $i->{'inum'});
}

sub sql_do {
    my ($dbh,@sql) = @_;

    for my $statement (@sql) {
        debug("Executing \"$statement\"...\n");
        my $result = $dbh->do($statement)
            or die "SQL statement failed:\n    $statement\n"
                . $dbh->errstr . "\n";
    }
}

sub sql_execute {
    my ($dbh,$sql,@values) = @_;

    my $sth = $dbh->prepare($sql)
        or die "prepare($sql) failed: " . $dbh->errstr . "\n";

    $sth->execute(@values)
        or die $sql . " (" . join(",", @values) . ") failed: "
            . $dbh->errstr . "\n";
    debug($sql . " (" . join(",", @values) . ")\n");

    return $sth;
}

sub initdb {
    my $dbh = shift;

    my @newdb = (
            "begin transaction",
            "create table linkdups ("
                . "version unsigned integer primary key not null)",
            "create table inode ("
                . "id integer primary key not null,"
                . "dev unsigned integer not null,"
                . "inum unsigned integer not null,"
                . "nlink unsigned integer not null,"
                . "uid unsigned integer not null,"
                . "gid unsigned integer not null,"
                . "size unsigned bigint not null,"
                . "blocks unsigned bigint not null,"
                . "mtime unsigned bigint not null,"
                . "md5 char(32))",
            "commit"
        );

    my $temporary = $debug ? "" : "temporary";
    my @file_table = (
            "begin transaction",
            "create $temporary table file ("
                . "id integer primary key not null,"
                . "dev unsigned integer not null,"
                . "inum unsigned integer not null,"
                . "name text not null)",
            "commit"
        );

    if ($dbh->selectrow_array("select * from sqlite_master where type='table'")) {
        my $result = $dbh->selectrow_arrayref("select version from linkdups");

        if (defined($result)) {
            my $version = $result->[0];
            debug("Found a version $version database.\n");
        }
    } else {
        debug("Initializing database...\n");

        sql_do($dbh, @newdb);

        sql_execute($dbh, "insert into linkdups values (?)", $dbver);
    }

    sql_do($dbh, @file_table);

    return 1;
}

my %opt;
getopts('rvDnthc:', \%opt) or usage(1);

usage(0) if $opt{'h'};

$recursive = defined($opt{'r'}) ? 1 : 0;
$verbose =   defined($opt{'v'}) ? 1 : 0;
$debug =     defined($opt{'D'}) ? 1 : 0;
$dryrun =    defined($opt{'n'}) ? 1 : 0;
$usetimes =  defined($opt{'t'}) ? 1 : 0;

$dbfile = $opt{'c'} if (defined($opt{'c'}));

$SIG{'USR1'} = sub {
        print STDERR "files found: $numtotal, files checked: $num, bytes "
            . ($dryrun ? "recoverable" : "saved") . ": $total\n";
    };

if ($verbose or $debug) {
    eval { use Time::HiRes qw(gettimeofday tv_interval); };
    $start = [gettimeofday] if (!$@);
}

my @files;
if (@ARGV) {
    @files = @ARGV;
} else {
    if ($recursive) {
        @files = (".");
    } else {
        usage(1);
    }
}

$dbh = DBI->connect("dbi:SQLite:$dbfile")
    or die "Couldn't connect to database: " . DBI->errstr;

initdb($dbh);

# Pass 1 - stat() everything.
for my $file (@files) {
    if (!(@statbuf = lstat($file))) {
        warn basename($0), ": $file: $!\n";
        next;
    }

    if ($recursive and (-d(_))) {
        recurse_into($file);
    } elsif (-f(_)) {
        stuff($file);
    } else {
        warn "$file: not a regular file\n";
        next;
    }
}

if ($verbose or $debug) {
    my $elapsed;

    if ($start) {
        $pass1 = [gettimeofday];
        $elapsed = tv_interval($start, $pass1);
    } else {
        $pass1 = time;
        $elapsed = $pass1-$^T;
    }
    info "$numtotal files scanned in $elapsed seconds.\n";
}

our $context = new Digest::MD5;

# Pass 2 - Check for potential duplicates and md5sum them.
my $stuff = "inode.dev || '.' || inode.size";
$stuff .= " || '.' || inode.mtime" if ($usetimes);
my $sth = sql_execute($dbh,
    "select distinct inode.dev,inode.inum"
    . " from inode,file where inode.dev=file.dev and inode.inum=file.inum"
    . " and inode.md5 is null"
    . " and ($stuff) in"
    . " (select ($stuff) as stuff"
    . " from inode,file where inode.dev=file.dev and inode.inum=file.inum"
    . " group by stuff having count(stuff)>1)"
    . " order by inode.blocks desc,inode.size desc");

while (my $inode = $sth->fetchrow_hashref()) {
    my $sth = sql_execute($dbh,
        "select inode.dev,inode.inum,inode.blocks,inode.size,file.name"
        . " from inode,file where inode.dev=file.dev and inode.inum=file.inum"
        . " and file.dev=? and file.inum=?"
        . " limit 1",
        $inode->{'dev'},
        $inode->{'inum'});
    my $file = $sth->fetchrow_hashref();
    debug("Found potential duplicate: " . $file->{'name'}
        . " [" . $file->{'dev'} . "/" . $file->{'inum'} . "] size="
        . $file->{'size'} . " (" . $file->{'blocks'} . " blocks)\n");
    checksum($context, $file);
}

info "$num files checked in ";
if ($start) {
    info tv_interval($pass1);
} else {
    info time-$pass1;
}
info " seconds ($numtotal files scanned).\n";

# Pass 3 - Link duplicates.
$stuff .= " || '.' || inode.md5";
$sth = sql_execute($dbh,
    "select distinct inode.dev,inode.size,inode.md5"
    . ($usetimes ? ",inode.mtime" : '')
    . " from inode,file where inode.dev=file.dev and inode.inum=file.inum"
    . " and ($stuff) in"
    . " (select distinct ($stuff) as stuff"
    . " from inode,file where inode.dev=file.dev and inode.inum=file.inum"
    . " group by stuff having count(stuff)>1)"
    . " order by inode.blocks desc,inode.size desc,inode.nlink desc");

while (my $dup = $sth->fetchrow_hashref()) {
    info "Processing duplicate "
        . $dup->{'md5'}
        . " (size "
        . $dup->{'size'}
        . " bytes)...\n";

    my @args = ($dup->{'dev'}, $dup->{'size'}, $dup->{'md5'});
    push(@args, $dup->{'mtime'}) if ($usetimes);
    my $filesth = sql_execute($dbh,
        "select file.name from inode,file"
        . " where inode.dev=file.dev and inode.inum=file.inum"
        . " and inode.dev=? and inode.size=? and inode.md5=?"
        . ($usetimes ? " and inode.mtime=?" : '')
        . " order by inode.blocks desc,inode.nlink desc",
        @args);
    my $file = $filesth->fetchall_arrayref();
    if ($debug) {
        use Data::Dumper;
        debug(Dumper($file));
    }

    next unless (@{$file} > 1);

    debug("Linking " . scalar(@{$file}) . " duplicates" #. " ("
        #. scalar(map { @{$data{$dev}->{$size}->{$_}->{'files'}} }
        #    @{$dup{$hash}})
        #. " files)"
        . " of size $dup->{'size'}\n");

    #my @inodes = sort {
    #        $data{$dev}->{$size}->{$b}->{'links'}
    #        <=> $data{$dev}->{$size}->{$a}->{'links'}
    #    } @{$dup{$hash}};
    
    # FIXME -
    # Logic is all wrong here.  We need to pull exactly one filename
    # for an inode to use as our "master" inode, then hardlink all
    # the other filenames to that.
    #my $master = shift @inodes;
    #my $source = $data{$dev}->{$size}->{$master}->{'files'}->[0];

    #for my $inode (@inodes) {
    #    debug("$dev:$master ("
    #        . $data{$dev}->{$size}->{$master}->{'links'}
    #        . " links) -> $dev:$inode ("
    #        . $data{$dev}->{$size}->{$inode}->{'links'}
    #        . " links)\n");

    #    for my $file
    #        (@{$data{$dev}->{$size}->{$inode}->{'files'}}) {
    #        if ($dryrun) {
    #            debug("unlinking $file...\n");
    #            debug("linking $source to $file...\n");
    #        } else {
    #            debug("unlinking $file...\n");
    #            if (unlink($file)) {
    #                debug("linking $source to $file...\n");
    #                link($source, $file)
    #                    or die "link($source,$file) failed: $!\n";
    #            } else {
    #                warn "unlink($file) failed: $!\n";
    #                next;
    #            }
    #        }

    #        $data{$dev}->{$size}->{$master}->{'links'}++;
    #    }

    #    if (!$dryrun) {
    #        @statbuf = stat($source);
    #        warn "Actual link count != expected!\n"
    #            if ($data{$dev}->{$size}->{$master}->{'links'}
    #                != $statbuf[3]);
    #    }

    #    $total += $size;
    #}
}

info "$total bytes ";
info "would be " if ($dryrun);
info "saved.\n";

$dbh->disconnect;

# vi: set ai et:
